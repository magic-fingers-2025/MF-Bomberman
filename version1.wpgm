import wollok.game.*

program bomberman {

  game.title("Bomberman UNaHur")
  game.width(13)
  game.height(12)
  game.cellSize(50)
  game.boardGround("fondoVacio.png")
  game.sound("tntACDC.mp3")

  // =====================
  // PERSONAJE PRINCIPAL
  // =====================
  game.addVisual(personaje)

  // Generar muros irrompibles + rompibles
  personaje.agregarMuros()

  // =====================
  // INTERFAZ (vidas y puntaje)
  // =====================
  interfaz.mostrar()
  interfaz.reiniciar()

  // =====================
  // CONTROLES DE MOVIMIENTO
  // =====================
  keyboard.w().onPressDo({ personaje.moverseHaciaArriba() })
  keyboard.s().onPressDo({ personaje.moverseHaciaAbajo() })
  keyboard.d().onPressDo({ personaje.moverseHaciaDerecha() })
  keyboard.a().onPressDo({ personaje.moverseHaciaIzquierda() })
  keyboard.space().onPressDo({ personaje.colocarBomba() })

  // =====================
  // RIVALES (enemigos)
  // =====================
  const rivales = [
    new Rival(numero = 1, position = game.at(11, 9)),
    new Rival(numero = 2, position = game.at(9, 3))
  ]

  rivales.forEach { rival =>
    game.addVisual(rival)

    // ColisiÃ³n con el jugador â†’ le quita vida
    game.onCollideDo(rival, { otro =>
      if (otro == personaje) {
        personaje.chocarCon(rival)
      }
    })

    // Movimiento automÃ¡tico cada 2 segundos
    game.schedule(2000, {
      rival.moverAleatorioSiLibre(personaje)
    })
  }

  // =====================
  // INICIO DEL JUEGO
  // =====================
  game.start()
}

// ====================================================
// PERSONAJE PRINCIPAL
// ====================================================

object personaje {
  
  var property position = game.at(3, 2)
  var property direccion = "frente"
  var property frameActual = 1
  var sonidoCaminar = game.sound("player_run.mp3")
  var property coordenadasBloqueadas = [] // se llena dinÃ¡micamente

  // =======================
  // IMAGEN SEGÃšN DIRECCIÃ“N
  // =======================
  method image() {
    if (direccion == "frente") return "frente.png"
    else if (direccion == "izquierda") {
      if (frameActual == 1) return "izquierda.png"
      else if (frameActual == 2) return "caminaIzq1.png"
      else return "correizq.png"
    }
    else if (direccion == "derecha") return "derecha.png"
    else if (direccion == "arriba") {
      if (frameActual == 1) return "Sube1.png"
      else if (frameActual == 2) return "Sube2.png"
      else return "Sube3.png"
    }
    else if (direccion == "abajo") {
      if (frameActual == 1) return "Baja1.png"
      else if (frameActual == 2) return "Baja2.png"
      else return "Baja3.png"
    }
    else return "frente.png"
  }

  method avanzarFrame() {
    frameActual = frameActual + 1
    if (frameActual > 3) frameActual = 1
  }

  // =======================
  // MOVIMIENTOS
  // =======================
  method moverseHaciaArriba() {
    direccion = "arriba"
    const nuevaPos = position.up(1)
    if (not self.estaBloqueada(nuevaPos.x(), nuevaPos.y())) {
      position = nuevaPos
      self.avanzarFrame()
      sonidoCaminar.play()
    }
  }

  method moverseHaciaAbajo() {
    direccion = "abajo"
    const nuevaPos = position.down(1)
    if (not self.estaBloqueada(nuevaPos.x(), nuevaPos.y())) {
      position = nuevaPos
      self.avanzarFrame()
      sonidoCaminar.play()
    }
  }

  method moverseHaciaDerecha() {
    direccion = "derecha"
    const nuevaPos = position.right(1)
    if (not self.estaBloqueada(nuevaPos.x(), nuevaPos.y())) {
      position = nuevaPos
      self.avanzarFrame()
      sonidoCaminar.play()
    }
  }

  method moverseHaciaIzquierda() {
    direccion = "izquierda"
    const nuevaPos = position.left(1)
    if (not self.estaBloqueada(nuevaPos.x(), nuevaPos.y())) {
      position = nuevaPos
      self.avanzarFrame()
      sonidoCaminar.play()
    }
  }

  // =======================
  // BLOQUEO DE MOVIMIENTOS
  // =======================
  method estaBloqueada(x, y) {
    return coordenadasBloqueadas.any { par => par.get(0) == x and par.get(1) == y }
  }

  // =======================
  // GENERACIÃ“N DE MUROS
  // =======================
  method agregarMuros() {
    (0..game.width() - 1).forEach { x =>
      (1..game.height() - 1).forEach { y => // fila 0 reservada para HUD
        if (x == 0 or y == 1 or x == game.width() - 1 or y == game.height() - 1 or (x % 2 == 0 and y % 2 == 0)) {
          const muro = object {
            var property position = game.at(x, y)
            method image() { return "muro.png" }
          }
          game.addVisual(muro)
          coordenadasBloqueadas.add([x, y])
        }
      }
    }
  }

  // =======================
  // COLISIÃ“N CON RIVAL
  // =======================
  method chocarCon(rival) {
    game.say(personaje, "Â¡Te atrapÃ³ el rival " + rival.numero() + "!")
    interfaz.perderUnaVida()
  }

  // =======================
  // COLOCAR BOMBA
  // =======================
  method colocarBomba() {
    const bomba = new Bomba(posicion = self.position(), posicionesProhibidas = self.coordenadasBloqueadas())
    game.addVisual(bomba)
  }
}

// ====================================================
// CLASES
// ====================================================

class Rival {
  // identificador opcional
  var property numero
  // posiciÃ³n en el tablero (debe pasarse al crear la instancia)
  var property position

  // sprite (solo una imagen disponible)
  method image() = "rival1.png"

    method iniciarMovimientoAleatorio(personaje) {
  game.schedule(2000, {
    self.moverAleatorioSiLibre(personaje)
  })
}
  /*
    Movimiento simple y seguro:
    - elige aleatoriamente una de las 4 direcciones
    - si la celda destino NO estÃ¡ bloqueada (usar personaje.estaBloqueada),
      entonces actualiza su posiciÃ³n; si estÃ¡ bloqueada, no hace nada.
  */
  method moverAleatorioSiLibre(personaje) {
    const direccion = [
      position.up(1),
      position.down(1),
      position.left(1),
      position.right(1)
    ].anyOne() // elige una direcciÃ³n al azar

    // verifica con el objeto personaje si la celda estÃ¡ bloqueada
    if (not personaje.estaBloqueada(direccion.x(), direccion.y())) {
      position = direccion
    }
    // si estÃ¡ bloqueada: no hace nada (queda en su lugar)
  }


  // helper: mover hacia el jugador (si querÃ©s mantener una versiÃ³n simple que no atraviese muros)
  method acercarseA(objetivo) {
    // intentamos priorizar ejes por diferencia, pero siempre chequeando bloqueo mediante objetivo.estaBloqueada
    const dx = objetivo.position().x() - position.x()
    const dy = objetivo.position().y() - position.y()

    // preferencia simple: mover en el eje con mayor diferencia; si estÃ¡ bloqueado, no intentar alternativas complejas
    if (dx.abs() >= dy.abs()) {
      const destino = if (dx > 0) position.right(1) else position.left(1)
      if (not objetivo.estaBloqueada(destino.x(), destino.y())) {
        position = destino
      }
    } else {
      const destino = if (dy > 0) position.down(1) else position.up(1)
      if (not objetivo.estaBloqueada(destino.x(), destino.y())) {
        position = destino
      }
    }
    // si el destino preferido estÃ¡ bloqueado, no hace nada (queda quieto)
  }
}


class Bomba {
  const property posicion
  const property posicionesProhibidas
  method image() = "bombaInicial.png"
}

// ====================================================
// INTERFAZ DE VIDAS Y PUNTAJE
// ====================================================

object interfaz {

  var property vidasRestantes = 3
  var property puntaje = 0

  var vida1 = object {
    method position() = game.at(1, 0)
    method image() = "corazon.png"
  }
  var vida2 = object {
    method position() = game.at(2, 0)
    method image() = "corazon.png"
  }
  var vida3 = object {
    method position() = game.at(3, 0)
    method image() = "corazon.png"
  }

  var marcador = object {
    method position() = game.at(9, 0)
    method draw(g) {
      g.setColor("white")
      g.drawText("Puntaje: " + interfaz.puntaje, 0, 0)
    }
  }

  // --- Mostrar elementos ---
  method mostrar() {
    game.addVisual(vida1)
    game.addVisual(vida2)
    game.addVisual(vida3)
    game.addVisual(marcador)
  }

  // --- Actualizar vidas visibles ---
  method actualizar() {
    game.removeVisual(vida1)
    game.removeVisual(vida2)
    game.removeVisual(vida3)
    if (vidasRestantes >= 1) game.addVisual(vida1)
    if (vidasRestantes >= 2) game.addVisual(vida2)
    if (vidasRestantes >= 3) game.addVisual(vida3)
  }

  // --- Perder vida ---
  method perderUnaVida() {
    vidasRestantes = vidasRestantes - 1
    self.actualizar()
    if (vidasRestantes == 0) {
      game.say(personaje, "ðŸ’€ Â¡Perdiste todas las vidas!")
      game.stop()
    }
  }

  // --- Sumar puntos ---
  method sumarPuntos(cantidad) {
    puntaje = puntaje + cantidad
  }

  // --- Reiniciar interfaz ---
  method reiniciar() {
    vidasRestantes = 3
    puntaje = 0
    self.actualizar()
  }
}
