import wollok.game.*

program bomberman {

  game.title("Bomberman UNaHur")
  game.width(13)
  game.height(11)
  game.cellSize(50)
  game.boardGround("fondoVacio.png")

  // Agregamos personaje
  game.addVisual(personaje)

  // Generar muros irrompibles + rompibles
  personaje.agregarMuros()

  // Controles de movimiento
  keyboard.w().onPressDo({ personaje.moverseHaciaArriba() })
  keyboard.s().onPressDo({ personaje.moverseHaciaAbajo() })
  keyboard.d().onPressDo({ personaje.moverseHaciaDerecha() })
  keyboard.a().onPressDo({ personaje.moverseHaciaIzquierda() })
  keyboard.space().onPressDo({ personaje.colocarBomba()
  })

  // =====================
  // RIVALES (enemigos)
  // =====================
  const rivales = [
    new Rival(numero = 1, position = game.at(11, 9)),
    new Rival(numero = 2, position = game.at(9, 3))
  ]

  rivales.forEach { rival =>
    game.addVisual(rival)

    // Detección de colisión con jugador
    game.onCollideDo(rival, { otro =>
      if (otro == personaje) {
        personaje.chocarCon(rival)
      }
    })

    // Movimiento automático hacia el jugador
    game.onTick((1.randomUpTo(5) * 500), "movimiento", {
      rival.acercarseA(personaje)
    })
  }

  game.start()
}

object personaje {

  var property position = game.at(1, 1)
  var property direccion = "frente"
  var property frameActual = 1
  var sonidoCaminar = game.sound("player_run.mp3")

  var property coordenadasBloqueadas = [] // se llena dinámicamente

  // =======================
  // IMAGEN SEGÚN DIRECCIÓN
  // =======================
  method image() {
    if (direccion == "frente") return "frente.png"
    else if (direccion == "izquierda") {
      if (frameActual == 1) return "izquierda.png"
      else if (frameActual == 2) return "caminaIzq1.png"
      else return "correizq.png"
    }
    else if (direccion == "derecha") return "derecha.png"
    else if (direccion == "arriba") {
      if (frameActual == 1) return "Sube1.png"
      else if (frameActual == 2) return "Sube2.png"
      else return "Sube3.png"
    }
    else if (direccion == "abajo") {
      if (frameActual == 1) return "Baja1.png"
      else if (frameActual == 2) return "Baja2.png"
      else return "Baja3.png"
    }
    else return "frente.png"
  }

  // =======================
  // ANIMACIÓN DE MOVIMIENTO
  // =======================
  method avanzarFrame() {
    frameActual = frameActual + 1
    if (frameActual > 3) frameActual = 1
  }

  // =======================
  // MOVIMIENTOS
  // =======================
  method moverseHaciaArriba() {
    direccion = "arriba"
    const nuevaPos = position.up(1)
    if (not self.estaBloqueada(nuevaPos.x(), nuevaPos.y())) {
      position = nuevaPos
      self.avanzarFrame()
      sonidoCaminar.play()
    }
  }

  method moverseHaciaAbajo() {
    direccion = "abajo"
    const nuevaPos = position.down(1)
    if (not self.estaBloqueada(nuevaPos.x(), nuevaPos.y())) {
      position = nuevaPos
      self.avanzarFrame()
      sonidoCaminar.play()
    }
  }

  method moverseHaciaDerecha() {
    direccion = "derecha"
    const nuevaPos = position.right(1)
    if (not self.estaBloqueada(nuevaPos.x(), nuevaPos.y())) {
      position = nuevaPos
      self.avanzarFrame()
      sonidoCaminar.play()
    }
  }

  method moverseHaciaIzquierda() {
    direccion = "izquierda"
    const nuevaPos = position.left(1)
    if (not self.estaBloqueada(nuevaPos.x(), nuevaPos.y())) {
      position = nuevaPos
      self.avanzarFrame()
      sonidoCaminar.play()
    }
  }

  // =======================
  // BLOQUEO DE MOVIMIENTOS
  // =======================
  method estaBloqueada(x, y) {
    return coordenadasBloqueadas.any { par => par.get(0) == x and par.get(1) == y }
  }

  // =======================
  // GENERACIÓN DE MUROS
  // =======================
  method agregarMuros() {

    // Muros perimetrales + internos fijos
    (0..game.width() - 1).forEach { x =>
      (0..game.height() - 1).forEach { y =>
        if (x == 0 or y == 0 or x == game.width() - 1 or y == game.height() - 1 or (x % 2 == 0 and y % 2 == 0)) {
          const muro = object {
            var property position = game.at(x, y)
            method image() { return "muro.png" }
          }
          game.addVisual(muro)
          coordenadasBloqueadas.add([x, y])
        }
      }
    }

    // Muros rompibles aleatorios
/* faltaria definir posiciones para ponerlos fijos

    (1..game.width() - 2).forEach { x =>
      (1..game.height() - 2).forEach { y =>
        if (not self.estaBloqueada(x, y) and not self.esZonaInicial(x, y) and random() < 0.25) {
          const muroRompible = object {
            var property position = game.at(x, y)
            method image() { return "MuroRompibleInicial.png" }
          }
          game.addVisual(muroRompible)
          coordenadasBloqueadas.add([x, y])
        }
      }
    }
    */
  }

  // =======================
  // ZONA DE APARICIÓN SEGURA
  // =======================
  method esZonaInicial(x, y) {
    return (x <= 2 and y <= 2)
  }


  // =======================
  // COLISIÓN CON RIVAL
  // =======================
  
  // no anda !!! si lo ven que fallaria joya
  method chocarCon(rival) {
    game.say(personaje,"¡Te atrapó el rival " + rival.numero() + "!")
  }

    // =======================
  // COLOCAR BOMBA
  // =======================

  /// hay que poner una bomba y que la bomba cambie su estado
method colocarBomba() {
  const bomba = new Bomba(posicion =self.position(), posicionesProhibidas = self.coordenadasBloqueadas())
  game.addVisual(bomba)
}

}

class Rival {
  // identificador opcional
  var property numero
  // posición en el tablero (debe pasarse al crear la instancia)
  var property position

  // sprite (solo una imagen disponible)
  method image() = "rival1.png"

  /*
    Movimiento simple y seguro:
    - elige aleatoriamente una de las 4 direcciones
    - si la celda destino NO está bloqueada (usar personaje.estaBloqueada),
      entonces actualiza su posición; si está bloqueada, no hace nada.
  */
  method moverAleatorioSiLibre(personaje) {
    const direccion = [
      position.up(1),
      position.down(1),
      position.left(1),
      position.right(1)
    ].anyOne() // elige una dirección al azar

    // verifica con el objeto personaje si la celda está bloqueada
    if (not personaje.estaBloqueada(direccion.x(), direccion.y())) {
      position = direccion
    }
    // si está bloqueada: no hace nada (queda en su lugar)
  }

  // helper: mover hacia el jugador (si querés mantener una versión simple que no atraviese muros)
  method acercarseA(objetivo) {
    // intentamos priorizar ejes por diferencia, pero siempre chequeando bloqueo mediante objetivo.estaBloqueada
    const dx = objetivo.position().x() - position.x()
    const dy = objetivo.position().y() - position.y()

    // preferencia simple: mover en el eje con mayor diferencia; si está bloqueado, no intentar alternativas complejas
    if (dx.abs() >= dy.abs()) {
      const destino = if (dx > 0) position.right(1) else position.left(1)
      if (not objetivo.estaBloqueada(destino.x(), destino.y())) {
        position = destino
      }
    } else {
      const destino = if (dy > 0) position.down(1) else position.up(1)
      if (not objetivo.estaBloqueada(destino.x(), destino.y())) {
        position = destino
      }
    }
    // si el destino preferido está bloqueado, no hace nada (queda quieto)
  }
}


class Bomba{
  const property posicion
  const property posicionesProhibidas
  
  method image()= "bombaInicial.png"
  
  }